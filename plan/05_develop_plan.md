# AI小说写作工具 - 开发清单 (Checklist)**

## 阶段 0: 项目启动与基础架构搭建**

*   [ ] **环境与工具:**
    *   [ ] 确认所有开发者的macOS (M4) 开发环境配置完毕 (Node.js, Rust, Python, IDEs)。
    *   [ ] Git版本控制系统初始化并配置好远程仓库。
    *   [ ] 选择并确认前端框架 (React 或 Vue)。
    *   [ ] 创建Tauri基础项目。
    *   [ ] 创建FastAPI基础项目。
    *   [ ] 配置代码格式化工具 (Prettier, Black)。
    *   [ ] 配置代码检查工具 (ESLint, Flake8/Pylint)。
*   [ ] **项目规划与规范:**
    *   [ ] 确定项目整体目录结构。
    *   [ ] 制定并共享初始的编码规范和命名约定。
    *   [ ] 初步设计核心数据模型 (小说项目结构、用户配置等)。
    *   [ ] (可选) 搭建基础CI/CD流水线。

---

**阶段 1: MVP - 核心编辑与基础AI集成**

*   [ ] **Tauri应用基础:**
    *   [ ] 实现Tauri应用基本窗口和菜单栏 (文件 -> 新建、打开、保存)。
    *   [ ] 实现小说项目文件的创建、读取、保存逻辑 (本地文件系统)。
*   [ ] **富文本编辑器 (Tiptap):**
    *   [ ] Tiptap成功集成到前端框架。
    *   [ ] 实现基础文本格式化 (加粗、斜体、下划线)。
    *   [ ] 实现标题层级 (H1-H6)。
    *   [ ] 实现列表功能 (有序、无序)。
    *   [ ] 实现引用块功能。
    *   [ ] 实现撤销/重做功能。
    *   [ ] (可选) 实现Markdown快捷输入支持。
*   [ ] **后端AI接口:**
    *   [ ] FastAPI后端创建用于AI功能的API端点。
    *   [ ] 成功连接到至少一个LLM API (如OpenAI)。
    *   [ ] 实现API密钥的安全管理方式 (初期可简单配置在`.env`)。
    *   [ ] 完成LLM API请求的封装和错误处理。
*   [ ] **首个AI功能：内容扩写:**
    *   [ ] 前端：用户可选中文字并通过UI触发“扩写”功能。
    *   [ ] 后端：接收文本和上下文，构建有效的Prompt调用LLM。
    *   [ ] 前端：清晰展示AI生成的扩写建议。
    *   [ ] 前端：用户可选择接受、修改或拒绝AI建议并应用到编辑器。
*   [ ] **第二个AI功能：内容改写/润色:**
    *   [ ] (类似扩写) 实现“改写/润色”功能，提供不同风格选项。
*   [ ] **UI/UX 初步:**
    *   [ ] 应用有基本一致的视觉主题和布局。
    *   [ ] 核心交互流程顺畅。
*   [ ] **阶段性检查:**
    *   [ ] MVP功能内部测试通过。
    *   [ ] 代码符合初期制定的规范。
    *   [ ] 关键逻辑有初步注释。

---

**阶段 2: 知识获取与初步RAG**

*   [ ] **网络搜索功能:**
    *   [ ] 后端：集成搜索引擎API或开发基础爬虫模块。
    *   [ ] 前端：提供搜索输入框。
    *   [ ] 前端：清晰展示网络搜索结果。
    *   [ ] (可选) 搜索结果可初步清洗和摘要。
*   [ ] **用户知识库 (向量存储):**
    *   [ ] 后端：选择并配置向量数据库 (如ChromaDB)。
    *   [ ] 后端：实现文本分块 (chunking) 逻辑。
    *   [ ] 后端：实现文本向量化逻辑 (使用Sentence Transformers等)。
    *   [ ] 后端：实现将处理后的文本存入向量数据库的API。
    *   [ ] 前端：用户可上传指定格式文档 (txt, md) 到知识库。
    *   [ ] 前端：提供基本的知识库内容管理界面。
*   [ ] **RAG功能：基于知识库的问答/内容生成:**
    *   [ ] 后端：实现从向量数据库进行语义检索的逻辑。
    *   [ ] 后端：将检索到的上下文与用户查询/写作需求结合，构建RAG Prompt。
    *   [ ] 后端：调用LLM生成基于知识库内容的回答或建议。
    *   [ ] 前端：用户可通过界面触发基于知识库的AI功能。
*   [ ] **AI功能扩展 (利用RAG):**
    *   [ ] 实现“大纲撰写”功能，可参考用户知识库。
    *   [ ] 实现“灵感激发”功能，可参考用户知识库。
*   [ ] **数据持久化 (结构化数据):**
    *   [ ] 后端：集成PostgreSQL。
    *   [ ] 定义并创建用于存储项目元数据、用户配置等的数据表。
*   [ ] **阶段性检查:**
    *   [ ] 知识获取与RAG功能按预期工作。
    *   [ ] 数据能正确存取。
    *   [ ] API接口文档 (如FastAPI自动生成的Swagger) 保持更新。

---

**阶段 3: 小说内部知识图谱构建**

*   [ ] **图数据库基础:**
    *   [ ] 后端：选择并配置图数据库 (如Neo4j)。
    *   [ ] 熟悉图数据库的查询语言 (如Cypher)。
*   [ ] **知识图谱设计与实现:**
    *   [ ] 定义小说核心实体类型 (人物、地点、事件等)。
    *   [ ] 定义实体间的核心关系类型。
    *   [ ] 前端：实现手动录入和编辑实体及其属性的界面 (如角色卡片)。
    *   [ ] 前端：实现手动创建和编辑实体间关系的界面。
    *   [ ] 后端：提供API将前端录入的图谱数据存储到Neo4j。
    *   [ ] 后端：实现对知识图谱的基本增删改查API。
*   [ ] **(进阶) 辅助提取与可视化:**
    *   [ ] 后端：(可选) 集成NLP工具初步从文本中识别实体。
    *   [ ] 前端：(可选) 实现知识图谱的简单可视化展示。
*   [ ] **阶段性检查:**
    *   [ ] 用户可以构建和编辑小说知识图谱。
    *   [ ] 图谱数据能正确存储和查询。
    *   [ ] (若实现) 可视化能基本反映图谱结构。

---

**阶段 4: Graph RAG 与高级AI功能**

*   [ ] **Graph RAG 实现:**
    *   [ ] 后端：实现将AI的上下文需求转换为对知识图谱的查询逻辑。
    *   [ ] 后端：将从图谱检索到的结构化信息融入LLM的Prompt。
    *   [ ] 后端：(可选) 探索Graph RAG与向量RAG的协同策略。
*   [ ] **AI功能升级 (利用Graph RAG):**
    *   [ ] 优化“风格控制”功能，利用图谱中的角色性格等信息。
    *   [ ] 实现初步的“一致性检查”辅助功能 (基于图谱提示潜在冲突)。
*   [ ] **统一知识检索:**
    *   [ ] 后端：(可选) 设计并实现统一的知识检索服务层。
*   [ ] **富文本编辑器增强:**
    *   [ ] 根据需求为Tiptap添加高级功能 (如表格、评论等)。
*   [ ] **阶段性检查:**
    *   [ ] Graph RAG能有效提升AI生成内容与小说设定的一致性。
    *   [ ] 高级AI功能按预期工作。
    *   [ ] 核心业务逻辑有适当的单元测试覆盖。

---

**阶段 5: 自主AI Agent 初步实现 (探索性)**

*   [ ] **Agent架构与工具:**
    *   [ ] 后端：研究并选择/设计AI Agent的执行框架。
    *   [ ] 后端：将已有的AI功能和知识检索功能封装为Agent可调用的“工具”。
*   [ ] **Agent核心逻辑:**
    *   [ ] 后端：设计Agent的决策逻辑和核心Meta-Prompt。
    *   [ ] 后端：实现Agent的“思考-行动”循环。
*   [ ] **自主写作场景实现:**
    *   [ ] 实现至少一个自主写作场景 (如“续写章节”)。
    *   [ ] Agent能根据任务自主调用工具并生成内容。
*   [ ] **用户交互与监控:**
    *   [ ] 前端：提供界面展示Agent的工作状态或思考步骤。
    *   [ ] 前端：允许用户在关键节点进行干预或提供反馈。
*   [ ] **阶段性检查:**
    *   [ ] AI Agent能完成基本的自主写作任务。
    *   [ ] Agent的决策过程相对透明。
    *   [ ] 针对Agent的复杂逻辑进行充分测试和调试。

---

**阶段 6: 优化、完善与Beta测试**

*   [ ] **性能与体验优化:**
    *   [ ] 对应用进行性能分析，识别并优化瓶颈。
    *   [ ] 全面审查并打磨UI/UX，提升易用性和美观度。
*   [ ] **稳定性与文档:**
    *   [ ] 完善错误处理机制，增加日志记录。
    *   [ ] 修复已知Bug，进行全面的回归测试。
    *   [ ] 编写详细的用户手册、教程和FAQ。
*   [ ] **发布准备:**
    *   [ ] 进行内部Alpha测试。
    *   [ ] 准备Beta版本发布。
    *   [ ] 建立用户反馈收集渠道。
*   [ ] **持续改进:**
    *   [ ] 根据Beta用户反馈进行迭代改进。
    *   [ ] 制定后续版本的功能规划。

**通用检查项 (贯穿所有阶段):**

*   [ ] **代码规范:** 代码是否遵循项目制定的编码规范和命名约定？
*   [ ] **版本控制:** 所有有意义的更改是否都已提交到Git，并附带清晰的提交信息？
*   [ ] **注释与文档:** 复杂逻辑和重要决策是否有适当的注释？API文档是否更新？
*   [ ] **可读性:** 代码是否易于理解和维护？
*   [ ] **错误处理:** 是否对潜在错误进行了妥善处理？
*   [ ] **安全性:** 是否注意了常见的安全风险点 (如输入验证)？
*   [ ] **测试:** (根据阶段) 核心功能是否有相应的测试？
*   [ ] **依赖管理:** 依赖库是否保持更新？
